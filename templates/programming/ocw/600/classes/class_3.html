{% extends "base.html" %}
{% block content %}


<h2>Class 3: Problem Solving.</h2>

<p class="tab">Return to the discussion of finding the cube root of a perfect cube:</p>

<pre class="prettyprint lang-python">
###Find the cube root of a perfect cube
x = int(raw_input('Enter an integer: '))
ans = 0
while ans*ans*ans < abs(x):
    ans = ans + 1
    #print 'current guess =', ans
if ans*ans*ans != abs(x):
    print x, 'is not a perfect cube'
else:
    if x < 0:
        ans = -ans
    print 'Cube root of ' + str(x) + ' is ' + str(ans)
</pre>


<h3>Some things to think about:</h3>
<ul>
  <li>For what values of input will this function always stop?</li>
  <li>What assumptions have been made (int, positive etc)?</li>
  <li>Does it terminate?</li>
</ul>  

<p class="tab">It does terminate, but how do we know that?  It uses a decrementing function.</p>

<h3>Decrementing function:</h3>
<ul>
  <li>Maps a set of program variables (x) to an integer.</li>
  <li>When the loop is entered for the first time, this value is non-negative.</li>
  <li>As soon as the value is <= 0, the loop terminates</li>
  <li>The value is decreased each time through the loop; essentially counting down.</li>
</ul>  

<p class="tab">Thus the loop will stop, eventually. What is the specific decrementing function here?  [Abs(x)-ans**3].  The first time through the loop: 8-0, then 8-1, then 8-8 then the loop terminates.</p>

<p class="tab">Every time you write a loop, think about how and why that loop will terminate (good practices).  This specific example is pretty stupid; it calculates the cube root of perfect cubes:  Within the space of all numbers, this is fairly rare, so a fairly useless algorithm.  Additionally, it uses exhaustive enumeration, guess and check or in laymans terms: Brute force.  Interestingly, while the term 'brute force' often has a negative stigma, it is often perfectly acceptable provided the nature of the problem is understood: the worst case scenario is not bad.</p>

<h3>For Loop:  (varient of the while loop):</h3>

<p class="tab">For loops and while loops can be used interchangeably.  This is an implementation of the same algorithm using a for loop instead of a while loop.  Range(x,y)= [x,x+1,x+2....(y-1)].</p>


<pre class="prettyprint lang-python">
#Find the cube root of a perfect cube
x = int(raw_input('Enter an integer: '))
for ans in range(0, abs(x)+1):
    if ans**3 == abs(x):
        break
if ans**3 != abs(x):
    print x, 'is not a perfect cube'
else:
    if x < 0:
        ans = -ans
    print 'Cube root of ' + str(x) + ' is ' + str(ans)
</pre>

<p class="tab">Ok, somewhat interesting, we have a stupid program that finds the cube roots of perfect cubes.  Pretty useless program.  More interesting, lets find square roots of all numbers.  Non-perfect squares have irrational roots, so we must define some sort of acceptable error (epsilon).  Aproximation is central to the course, lots of times we look for an answer that is good enough, rather than exact (while in this instance, exact answers are impossible).</p>

<p class="tab">Find y (answer) such that y*y - x (input) =< e (acceptable error):</p>


<pre class="prettyprint lang-python">
x = 25
epsilon = 0.01
numGuesses = 0
ans = 0.0
while abs(ans**2 - x) >= epsilon and ans <= x:
    ans += 0.00001
    numGuesses += 1
print 'numGuesses =', numGuesses
if abs(ans**2 - x) >= epsilon:
    print 'Failed on square root of', x
else:
    print ans, 'is close to square root of', x
</pre>

<p class="tab">Output of this program:</p>


<pre class="prettyprint lang-python">
>>> 
numGuesses = 499900
4.99899999998 is close to square root of 25
>>> 
</pre>

<p class="tab">This is, once again, exhaustive enumeration going up.  It is gaurenteed to stop, because as ans grows, it will eventually reach x.  Or, as ans grows, x-ans^2 will decline, and <i>eventually</i> reach zero.  This process is quite fast for little numbers, and this program runs seemingly instantly.</p>


<h4>Estimate running time [what does it depend on]:</h4>

<ul>
  <li>How far we are from the answer</li>
  <li>How large is the error bound</li>
  <li>How large is the increment</li>
</ul>  

<p class="tab">For even moderately sized numbers, this process fails miserably, because the number of guesses is aproximately proportional to the answer.  The square root of 5 is answered quickly, the square root of one million, is not.</p>



<h3>Bisection Search:</h3>

<p class="tab">This is a much better method, here we try to eliminate half the possible answers each time through the loop, rather than increasing a little bit.  Pick a random number in the search space.  If guess is too high, eliminate all numbers higher than it, if the number too low, eliminate all numbers lower than it.  repeat</p>


<pre class="prettyprint lang-python">
x = 12345
epsilon = 0.01
numGuesses = 0
low = 0.0
high = x
ans = (high + low)/2.0
while abs(ans**2 - x) >= epsilon and ans <= x:
    #print low, high, ans
    numGuesses += 1
    if ans**2 < x:
        low = ans
    else:
        high = ans
    ans = (high + low)/2.0
#print 'numGuesses =', numGuesses
print ans, 'is close to square root of', x
</pre>

<p class="tab">Output of this program:</p>

<pre class="prettyprint lang-python">
>>> 
numGuesses = 26
111.108076461 is close to square root of 12345
>>> 
</pre>

<p class="tab">How big was the intial search space?  12345/.01 is the search space.  This number halves every time through the program, so its works fairly fast.</p>

<p class="tab">Much more important question: Does it work? <b>NO!</b>, there are some values for which this simply doesn't work because the answer isn't in the search space.  This means, the program runs FOREVER!  This is obviously bad.  Discuss this next time.  Suppose I wanted to find a function that found the cube root, how would I change this, or even more interestingly, the nth root.  As it stands, I'd have to go into the program and change it every time.  That won't do.  Next time:  Errors with this program and functions!</p>


{% endblock %}