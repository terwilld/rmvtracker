{% extends "base.html" %}
{% block content %}


<h2>Class 2: Core elements of a program.</h2>

<p class="tab">Launching into the core elements:  These exist in most languages the specifics of which are different; the general idea is the same.  He shows examples using IDLE: the Integrated Development Environment which comes with python by default.</p>


<h3>What does IDLE have:</h3>

<ul>
  <li>Text editor with highlighting and smart indent</li>
  <li>Shell: direct interactive interpreter</li>
  <li>Integrated debugger, [he doesn't use; I should look at]</li>
</ul>  

<h3>One can open a shell and start interacting with it</h3>

<ul>
  <li>At pythons core: Objects. Variables as well as programs themselves are objects</li>
  <li>Each object has a type, which dictates what can be done with or to that object</li>
  <li>Two main classes of types: Scaler and non-scaler</li>
</ul>  


<h3>Non-scaler are the indivisible building blocks</h3>
<ul>
  <li>Int: litteral 3 or type(3)= 'int'</li>
  <li>Float: Real numbers 3.3 or type(3.3) float. [aproximations, 3.2 into interpreter => 3.2000002 beware]</li>
  <li>Boolean:  True or False</li>
  <li>None:  This is a special word and type, often used to populate a variable whose value is yet unknown</li>
  <li>Python does NOT have a char type like some others, this is string instead</li>


</ul>  


  <a href="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%231.png">
  <img class="embed_img" src="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%231.png">
  </a>

<p class="tab">Litterals (things that you can type) can only bring you so far.  Expressions: sequences of operans [objects] + operators.  The operator '+' is overloaded, different meanings depending on the type of the objects.</p>

  <a href="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%232.png">
  <img class="embed_img" src="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%232.png">
  </a>

<p class="tab">The shell also will give you a number of syntax errors helping you figure out what you have done wrong.  Interestingly, you can force 2.1 to be an interger; he doesn't like this since it could allow unforseen results.</p>

  <a href="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%233.png">
  <img class="embed_img" src="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%233.png">
  </a>

<p class="tab">Most likely last time seeing the shell.  It's silly to keep typeing the same stuff.  Only good for quickly testing values.  Script examples: it evaluates expressions but does not put them on the screen unless explicitly told to with a print command. A program (or script) is simply a sequence of commands. x=3 this is assignment, duh.  Variables are merely names of objects; assignment binds a name to an object.  Comments enhance ability for another (or yourself at a later date) to understand what is going on in the program, what mentality is adopted.  Two types of input, raw_input only one used, converts everything to a string!</p>

  <a href="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%234.png">
  <img class="embed_img" src="https://s3-us-west-2.amazonaws.com/david-website/Programming/ocw/600/class_2/%234.png">
  </a>

<h3>So far, programs have been straight line programs:</h3>
<ul>
  <li>Obvious sequence; every command starting at the top</li>
  <li>Each command once and only once</li>
  <li>Boring, no tests, no feed back and no loops.</li>
  <li>Only the simplest, most uninteresting programs are straight-line</li>  
</ul>  

<p class="tab">Tests: Conditionals make things a bit more interesting:</p>

<pre class="prettyprint lang-python">
x = int(raw_input('Enter an integer: '))
if x%2 == 0:
    print 'Even'
else:
    print 'Odd'
    if x%3 != 0:
        print 'And not divisible by 3'
</pre>

<h3>Some notes on the above code;</h3>
<ul>
  <li>Indentation matters for the semantics: this is rare.</li>
  <li>Un-indenting "if x%3 !=0" changes the semantics, it is no longer nested</li>
  <li>Usually only aesthetic with specific characters</li>
</ul>  




<br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br>




<ul>
  <li>This is a gentle intro to somp sci / EE, 6.01 can be hard for those with no background</li>
  <li>Emphasis is on scientific problems, though some commercial applications arise</li>
  <li>Problem sets are in python.  Don't be fooled by the first two; course will get hard</li>
  <li>Quizes (2) and tests are open book open notes, the emphasis is problem solving, not memory / retention</li>
  <li>Collaboration policy: there is none, its impossible to get accused of plagurism, however using others may create a false sense of security before test/quizes</li>
  <li>No Lecture notes: hand outs are code, take your own notes; best way to learn</li>
  <li>No official text, though few recommended books can be helpful as references during exams</li>
</ul>  

<h2>Main goal: Computational problem solving</h2>

<ul>
  <li>Two kinds of knowledge:</li>
  <li>Declarative: statements of fact: "cake is unhealty in large amounts"</li>
  <li>Imperative: instructions on how to solve a problem: "recipe to make a cake"</li>
</ul>  


<h2>Example Imperative knowledge: Ancient method of finding (aprox) sqrt [Heron]</h2>


<ol>
  <li>Start with a guess (<i>g</i>)</li>
  <li>If g*g is close enough to x; g is sufficiently good as an aproximation for sqrt(x)</li>
  <li>Else: new guess is average of g and x/g =>   g(new) = [g(old) +x/g(old)] / 2 </li>
  <li>Return to step 2</li>
</ol>  

<h2>Example of such method</h2>

<ol>
  <li>Intial conditions: x=25, g=3</li>
  <li>g*g=9, this is not sufficiently close to 25</li>
  <li>new g is [3+(25/3)]*.5=5.6666</li>
  <li>Return to step 2</li>
  <li>g*g=32.1, this is not sufficiently close to 25</li>
  <li>new g is [5.6+(25/5.6)]*.5=5.03</li>
  <li>Return to step 2</li>
  <li>5.03*5.03 = 25.32; this is sufficiently close; loop terminates</li>

</ol>  
<br>
Possible excercise: make this in python code
<br>
<h2>Algorithm: how to perform a computation</h2>
<ul>
  <li>Steps of instruction</li>
  <li>Order of control</li>
  <li>Termination condition</li>
</ul>  
<h2>Shampoo is a fun example</h2>
<ul>
  <li>Rinse</li>
  <li>Lather</li>
  <li>Repeat</li>
</ul>  

<p class="tab">No termination step: This process should continue indefinitely</p>


<h2>Mechanically, how to do this?</h2>
<p class="tab">Initial computers were fixed program computers: these early examples were pretty boring and could only do one thing.  Early examples sloved systems of equations for artillary or broke enigma (Alan Turing).  The big break came with the stored program computer.  The instructions are not any different than data; infinitely more flexible: programs can produce programs.  Computers are now interpreters; they can execute any "legal" set of instructions.  There is also just memory, not program memory vs data memory.</p>

<p class="tab">Given a small set of instructions you can make a very large number of possible programs.  Python (surprisingly) only has dozens of primatives, these can be re-arranged for nearly infinite possible programs.  Alan Turing showed that with just 6 primatives, any program that can be written by a computer can be written with just these 6.  Python has more than 6 because the 6 are quite basic, levels of abstraction allow shorter programs.</p>

<p class="tab">Which instructions will we be using? This is the root of a programming language.</p>
 
<h3>A programming language specifies:</h3>
<ol>
  <li>The set of legal primatives</li>
  <li>The flow of control</li>
  <li>How these are combined [commands + flow of control + data = program].</li>  
</ol>

<p class="tab">Amazingly, a computer will do exactly what you tell it; this is both good and bad.  The computer doesn't "know what you mean" and the same program produces the exact same output, every time: It's a perfect object machine as contrasted with human language; plenty of subjectivity.</p>

<p class="tab">Which instructions will we be using? This is the root of a programming language.</p>

<p class="tab">This course uses Python, it is not a course about python but rather computation.  Python is simply the laguage used, any could subsitute.  The main characteristics of a langauge:</p>
<ol>
  <li>Syntax: Which sequences of symbols are well formed</li>
  <li>Static semantics: Which well formed strings have meaning eg 3+a is well formed [operan operator operan] but meaningless</li>
  <li>Semantics: Look at those which fulfill the above two conditions, and determine result.</li>  
</ol>

<h3>What happens when we have an error</h3>
<ol>
  <li>Crash</li>
  <li>May run forever</li>
  <li>Wrong answer</li>  
</ol>

<p class="tab">These are ordered best to worst; wrong answer are the hardest problem, because they may appear correct. It is also the hardest to debugg.</p>

<p class="tab">The choice of python has some upsides and some down sides: the static semantics are not that strict: 3.0/2=1 not 1.5.  Java has tighter static semantics.  However the forced indentation is seens as a good thing, since the visual layout of the program follows the semantics of the program.</p>

<h3>Why was python chosen?</h3>
<ul>
  <li>Easy to learn</li>
  <li>Very widly used in life sciences</li>
  <li>Easier to debug than most; because it is an interpreted language.  If something goes wrong, the interpreter says what happened</li>  
  <li>Trade off is that complied is faster [speed doesn't really matter until.... it does]</li>  
</ul>





{% endblock %}