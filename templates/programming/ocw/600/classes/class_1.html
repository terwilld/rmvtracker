{% extends "base.html" %}
{% block content %}






<h2>Intro to 6.00, general course information</h2>

<ul>
  <li>This is a gentle intro to somp sci / EE, 6.01 can be hard for those with no background</li>
  <li>Emphasis is on scientific problems, though some commercial applications arise</li>
  <li>Problem sets are in python.  Don't be fooled by the first two; course will get hard</li>
  <li>Quizes (2) and tests are open book open notes, the emphasis is problem solving, not memory / retention</li>
  <li>Collaboration policy: there is none, its impossible to get accused of plagurism, however using others may create a false sense of security before test/quizes</li>
  <li>No Lecture notes: hand outs are code, take your own notes; best way to learn</li>
  <li>No official text, though few recommended books can be helpful as references during exams</li>
</ul>  

<h2>Main goal: Computational problem solving</h2>

<ul>
  <li>Two kinds of knowledge:</li>
  <li>Declarative: statements of fact: "cake is unhealty in large amounts"</li>
  <li>Imperative: instructions on how to solve a problem: "recipe to make a cake"</li>
</ul>  


<h2>Example Imperative knowledge: Ancient method of finding (aprox) sqrt [Heron]</h2>


<ol>
  <li>Start with a guess (<i>g</i>)</li>
  <li>If g*g is close enough to x; g is sufficiently good as an aproximation for sqrt(x)</li>
  <li>Else: new guess is average of g and x/g =>   g(new) = [g(old) +x/g(old)] / 2 </li>
  <li>Return to step 2</li>
</ol>  

<h2>Example of such method</h2>

<ol>
  <li>Intial conditions: x=25, g=3</li>
  <li>g*g=9, this is not sufficiently close to 25</li>
  <li>new g is [3+(25/3)]*.5=5.6666</li>
  <li>Return to step 2</li>
  <li>g*g=32.1, this is not sufficiently close to 25</li>
  <li>new g is [5.6+(25/5.6)]*.5=5.03</li>
  <li>Return to step 2</li>
  <li>5.03*5.03 = 25.32; this is sufficiently close; loop terminates</li>

</ol>  
<br>
Possible excercise: make this in python code
<br>
<h2>Algorithm: how to perform a computation</h2>
<ul>
  <li>Steps of instruction</li>
  <li>Order of control</li>
  <li>Termination condition</li>
</ul>  
<h2>Shampoo is a fun example</h2>
<ul>
  <li>Rinse</li>
  <li>Lather</li>
  <li>Repeat</li>
</ul>  

<p class="tab">No termination step: This process should continue indefinitely</p>


<h2>Mechanically, how to do this?</h2>
<p class="tab">Initial computers were fixed program computers: these early examples were pretty boring and could only do one thing.  Early examples sloved systems of equations for artillary or broke enigma (Alan Turing).  The big break came with the stored program computer.  The instructions are not any different than data; infinitely more flexible: programs can produce programs.  Computers are now interpreters; they can execute any "legal" set of instructions.  There is also just memory, not program memory vs data memory.</p>

<p class="tab">Given a small set of instructions you can make a very large number of possible programs.  Python (surprisingly) only has dozens of primatives, these can be re-arranged for nearly infinite possible programs.  Alan Turing showed that with just 6 primatives, any program that can be written by a computer can be written with just these 6.  Python has more than 6 because the 6 are quite basic, levels of abstraction allow shorter programs.</p>

<p class="tab">Which instructions will we be using? This is the root of a programming language.</p>
 
<h3>A programming language specifies:</h3>
<ol>
  <li>The set of legal primatives</li>
  <li>The flow of control</li>
  <li>How these are combined [commands + flow of control + data = program].</li>  
</ol>

<p class="tab">Amazingly, a computer will do exactly what you tell it; this is both good and bad.  The computer doesn't "know what you mean" and the same program produces the exact same output, every time: It's a perfect object machine as contrasted with human language; plenty of subjectivity.</p>

<p class="tab">Which instructions will we be using? This is the root of a programming language.</p>

<p class="tab">This course uses Python, it is not a course about python but rather computation.  Python is simply the laguage used, any could subsitute.  The main characteristics of a langauge:</p>
<ol>
  <li>Syntax: Which sequences of symbols are well formed</li>
  <li>Static semantics: Which well formed strings have meaning eg 3+a is well formed [operan operator operan] but meaningless</li>
  <li>Semantics: Look at those which fulfill the above two conditions, and determine result.</li>  
</ol>

<h3>What happens when we have an error</h3>
<ol>
  <li>Crash</li>
  <li>May run forever</li>
  <li>Wrong answer</li>  
</ol>

<p class="tab">These are ordered best to worst; wrong answer are the hardest problem, because they may appear correct. It is also the hardest to debugg.</p>

<p class="tab">The choice of python has some upsides and some down sides: the static semantics are not that strict: 3.0/2=1 not 1.5.  Java has tighter static semantics.  However the forced indentation is seens as a good thing, since the visual layout of the program follows the semantics of the program.</p>

<h3>Why was python chosen?</h3>
<ul>
  <li>Easy to learn</li>
  <li>Very widly used in life sciences</li>
  <li>Easier to debug than most; because it is an interpreted language.  If something goes wrong, the interpreter says what happened</li>  
  <li>Trade off is that complied is faster [speed doesn't really matter until.... it does]</li>  
</ul>





{% endblock %}