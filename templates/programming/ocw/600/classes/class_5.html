{% extends "base.html" %}
{% block content %}



<p class="tab">Last lecture we looked at a program for finding aproximations of roots.  Instead, lets collect them, time to cover basic data structures.</p>

<h3>Data Structures!</h3>

<h4>Tuples:</h4>

<ul>
  <li>Tuples (ordered immutable)</li>  
  <li>Lists  (ordered mutable)</li>  
  <li>Dcitionaries (keys are immutable, values are mutable)</li>  
</ul>  

<p class="tab">Example using tuples:</p>

<pre class="prettyprint lang-python">
Test = (1, 2, 3, 4, 5)
print Test[0]  # print first element
print Test[1]  # print 2nd element
print Test     # print whole set
print Test[-1] # prints last element

#print Test[len(Test)]  This would fail because we index from 0 not 1, use -1 for last index.
</pre>

<p class="tab">Indexing is how to access items. Various operations for retrieving data.</p>

<p class="tab">More interesting example:</p>

<pre class="prettyprint lang-python">
x = 100
divisors = ()
for i in range(1,x):
    if x%i == 0:
        print divisors
        divisors = divisors+(i,)
print divisors
</pre>

<p class="tab">Finds all divisors of 100 (x) and collects them in a tuple.  The interesting syntax (i,) is required to tell the python interpreter that (i) is a tuple, this is a special case for tuples of length one.  Output:</p>


<pre class="prettyprint lang-python">
()
(1,)
(1, 2)
(1, 2, 4)
(1, 2, 4, 5)
(1, 2, 4, 5, 10)
(1, 2, 4, 5, 10, 20)
(1, 2, 4, 5, 10, 20, 25)
(1, 2, 4, 5, 10, 20, 25, 50)
</pre>

<p class="tab">Can see the tuple being built / added to as the program runs.</p>

<p class="tab">Subsets of the tuple can be taken with slicing as we could strings.</p>

<pre class="prettyprint lang-python">
divisors[1:3]
</pre>


<h4>Lists:</h4>

<p class="tab">These are potentially more interseting because they are mutable.  Tuples are immutable, once created they can not be changed.  Lists are the first mutable type.  Previously, assignment may appear to mutate, but it doesn't.  x=2 then x=3 doesn't change the object 2 or 3 rather it changes the object to which x the identifier is bound.</p>


<pre class="prettyprint lang-python">
Techs = ['MIT', 'Cal Tech']
Ivys = ['Harvard', 'Yale', 'Brown']
Univs = []
Univs.append(Techs)
print 'Univs =', Univs

Univs.append(Ivys)
print 'Univs =', Univs
for e in Univs:
    print 'e =', e

flat = Techs + Ivys
print 'flat =', flat

</pre>

<p class="tab">Append, is a method. It is similar to a function. Instead of append(L,e) I write L.append(e).  Later (with classes) methods are better than functions.  Very interesting point with regards to mutability.  The previous bit of code dealing with tuples and divisors may appear to append to a tuple; it does not.  Rather, every iteration of the tuple 'divisors' is infact a new tuple, remade to take a new value.  Here, append addes to a list without re-making it.</p>

<p class="tab">Output:</p>

<pre class="prettyprint lang-python">
Univs = [['MIT', 'Cal Tech']]
Univs = [['MIT', 'Cal Tech'], ['Harvard', 'Yale', 'Brown']]
e = ['MIT', 'Cal Tech']
e = ['Harvard', 'Yale', 'Brown']
flat = ['MIT', 'Cal Tech', 'Harvard', 'Yale', 'Brown']
</pre>

<p class="tab">Interesting, nested lists.  Flat is how you would get them un-nested</p>

<p class="tab">Removal now.  Interesting ramifications:</p>


<pre class="prettyprint lang-python">
Techs = ['MIT', 'Cal Tech']
Ivys = ['Harvard', 'Yale', 'Brown']
Univs = []
Univs.append(Techs)
print 'Univs =', Univs

Univs.append(Ivys)
print 'Univs =', Univs
for e in Univs:
    print 'e =', e

flat = Techs + Ivys
print 'flat =', flat

artSchools = ['RISD', 'Harvard']
for u2 in artSchools:
    if u2 in flat:
        flat.remove(u2)
print flat
</pre>

<p class="tab">Output:  Harvard removed.</p>

<pre class="prettyprint lang-python">
Univs = [['MIT', 'Cal Tech']]
Univs = [['MIT', 'Cal Tech'], ['Harvard', 'Yale', 'Brown']]
e = ['MIT', 'Cal Tech']
e = ['Harvard', 'Yale', 'Brown']
flat = ['MIT', 'Cal Tech', 'Harvard', 'Yale', 'Brown']
['MIT', 'Cal Tech', 'Yale', 'Brown']
</pre>

<p class="tab">Lists can be sorted:</p>

<pre class="prettyprint lang-python">
Techs = ['MIT', 'Cal Tech']
Ivys = ['Harvard', 'Yale', 'Brown']
flat = Techs + Ivys
print 'flat =', flat
flat.sort()
print 'flat =', flat
</pre>

<p class="tab">Output:  Put in alphabetical order.</p>

<pre class="prettyprint lang-python">
flat = ['MIT', 'Cal Tech', 'Harvard', 'Yale', 'Brown']
flat = ['Brown', 'Cal Tech', 'Harvard', 'MIT', 'Yale']
</pre>

<p class="tab">Mutate an element: This is different than assignment! Because the pointer is pointing to the same thign, the thing is different.  Key Point!  Assigment is binding names to objects, mutation is changing the values of objects.</p>

<pre class="prettyprint lang-python">
Techs = ['MIT', 'Cal Tech']
Ivys = ['Harvard', 'Yale', 'Brown']
flat = Techs + Ivys
print 'flat =', flat
flat.sort()
print 'flat =', flat
flat[1] = 'UMass'
print 'flat =', flat
</pre>

<p class="tab">Output:</p>

<pre class="prettyprint lang-python">
flat = ['MIT', 'Cal Tech', 'Harvard', 'Yale', 'Brown']
flat = ['Brown', 'Cal Tech', 'Harvard', 'MIT', 'Yale']
flat = ['Brown', 'UMass', 'Harvard', 'MIT', 'Yale']
</pre>


<p class="tab">Dull but purposeful example:</p>

<pre class="prettyprint lang-python">
L1 = [2]
L2 = [L1, L1]
print 'L2 =', L2
L1[0] = 3
print 'L2 =', L2
L2[0] = 'a'
print 'L2 =', L2

</pre>

<p class="tab">Output:</p>

<pre class="prettyprint lang-python">
L2 = [[2], [2]]
L2 = [[3], [3]]
L2 = ['a', [3]]
</pre>

<p class="tab">Lesson:  Having lists point to other lists can be very powerful but infuriating as well.</p>

<p class="tab">Very odd example:</p>

<pre class="prettyprint lang-python">
L1 = [2]
L2 = [L1, L1]
print 'L2 =', L2
L1[0] = 3
print 'L2 =', L2
L2[0] = 'a'
print 'L2 =', L2
L1 = [2]
print 'L2 =', L2
</pre>

<p class="tab">Output:</p>

<pre class="prettyprint lang-python">
L2 = [[2], [2]]
L2 = [[3], [3]]
L2 = ['a', [3]]
L2 = ['a', [3]]
</pre>


<p class="tab">This is FUNKY.  I expected the last line of the output to be ['a',2].  The last two lines are odd.  L1 = [2] is an assigment (not a mutation): L1 now points to a new object, 2.  The L2 still points to the object 2, so linked lists point to their objects and somewhat find the end of the hole, they don't point to the list, they point to the elements of the list. </p>

<p class="tab">New examples:</p>

<pre class="prettyprint lang-python">
def copyList(LSource, LDest):
    for e in LSource:
        LDest.append(e)
        print 'LDest =', LDest

L1 = []
L2 = [1,2,3]
copyList(L2,L1)
print L1
print L2
</pre>

<p class="tab">Output: as expected</p>

<pre class="prettyprint lang-python">
LDest = [1]
LDest = [1, 2]
LDest = [1, 2, 3]
[1, 2, 3]
[1, 2, 3]
</pre>

<p class="tab">Much more fun!</p>

<pre class="prettyprint lang-python">
def copyList(LSource, LDest):
    for e in LSource:
        LDest.append(e)
        print 'LDest =', LDest

L1 = []
L2 = [1,2,3]
copyList(L2,L1)
print L1
print L2
copyList(L1, L1)
print L1
</pre>

<p class="tab">This loops forever.  They are adding to the end and it keeps finding another thing to copy.  It is essentially chasing its tail.  This is an example of "aliasing".  An object with two (or mulptiple) names.  With immutable objects, aliasing doesn't matter, with mutable objects, it can be VERY horrible; if you modify through one name, yet access through another.</p>



<h4>Dictionary:</h4>

<p class="tab">Two key differences from lists.  The values are unordered.  Indexes can be any immutable type (they are called keys rather than indexes).</p>


<pre class="prettyprint lang-python">
D = {1: 'one', 'deux': 'two', 'pi': 3.14159}
print D['pi']
D1 = D
print D1
D[1] = 'uno'
print D1
for k in D1.keys():
    print k, '=', D1[k]
</pre>

<p class="tab">Output:</p>


<pre class="prettyprint lang-python">
3.14159
{1: 'one', 'pi': 3.14159, 'deux': 'two'}
{1: 'uno', 'pi': 3.14159, 'deux': 'two'}
1 = uno
pi = 3.14159
deux = two
</pre>

<p class="tab">Dictionaries are key value pairs.  It is a set of key value pairs.</p>

<p class="tab">More fun example:</p>

<pre class="prettyprint lang-python">
EtoF = {'bread': 'du pain', 'wine': 'du vin',\
        'eats': 'mange', 'drinks': 'bois',\
        'likes': 'aime', 1: 'un',\
        '6.00':'6.00'}
print EtoF
print EtoF.keys()
print EtoF.keys
del EtoF[1]
print EtoF
</pre>

<p class="tab">Ouput:</p>

<pre class="prettyprint lang-python">
{1: 'un', '6.00': '6.00', 'eats': 'mange', 'likes': 'aime', 'bread': 'du pain', 'drinks': 'bois', 'wine': 'du vin'}
[1, '6.00', 'eats', 'likes', 'bread', 'drinks', 'wine']
<built-in method keys of dict object at 0x7f9580c177f8>
{'6.00': '6.00', 'eats': 'mange', 'likes': 'aime', 'bread': 'du pain', 'drinks': 'bois', 'wine': 'du vin'}
</pre>


<p class="tab">Fun example for dictionaries:  Translations.</p>



<pre class="prettyprint lang-python">
EtoF = {'bread': 'du pain', 'wine': 'du vin',\
        'eats': 'mange', 'drinks': 'bois',\
        'likes': 'aime', 1: 'un',\
        '6.00':'6.00'}

def translateWord(word, dictionary):
    if word in dictionary:
        return dictionary[word]
    else:
        return word
    
def translate(sentence):
    translation = ''
    word = ''
    for c in sentence:
        if c != ' ':
            word = word + c
        else:
            translation = translation + ' '\
                          + translateWord(word, EtoF)
            word = ''
    return translation[1:] + ' ' + translateWord(word, EtoF)

print translate('John eats bread')
print translate('Steve drinks wine')
print translate('John likes 6.00')
</pre>


<p class="tab">Output:</p>

<pre class="prettyprint lang-python">
John mange du pain
Steve bois du vin
John aime 6.00
</pre>






{% endblock %}